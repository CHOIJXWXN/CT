'''
자리배정
[1, 1] 부터 시계방향으로 k번째 좌표
'''
# 아마도 정석과 비슷한 델타 방식
# R, C = map(int, input().split())                # 입력값 저장 (행, 열 개수)
# K = int(input())                                # 입력값 저장 (몇 번째 좌표인지)
# seats = [[0] * C for i in range(R)]             # 모든 좌석 0 초기화
# d = [[0, 1], [1, 0], [0, -1], [-1, 0]]          # 시계방향 (우 하 좌 상)
# x, y = 0, 0                                     # 시작 좌표
# seats[0][0] = 1                                 # 첫 좌석 번호 1
# i = 2                                           # 그 다음 좌석 번호
# j = 0                                           # 방향 인덱스

# if K > R * C:                                   # 좌석보다 더 큰 번호를 원하면
#     print(0)                                    # 0 출력

# # 정석방식은 nx, ny
# else:
#     while i <= K:                               # 좌석 번호가 K가 될 때까지
#         x += d[j % 4][0]                        # 좌표 수정
#         y += d[j % 4][1]                        # 좌표 수정
#         if 0 <= x < R and 0 <= y < C and not seats[x][y]:   # 수정된 좌표가 틀 안에 들어오고 배정된 좌석이 아닐 때
#             seats[x][y] = i                                 # 좌석 배정
#             i += 1                                          # 다음 좌석 번호
#         else:                                               # 틀 밖을 벗어났거나 이미 배정된 좌석일 때
#             x -= d[j % 4][0]                                # 수정된 좌표를 다시 원상 복구
#             y -= d[j % 4][1]                                # 수정된 좌표를 다시 원상 복구
#             j += 1                                          # 방향 인덱스 변경
#     print(x + 1, y + 1)                                     # 좌표 출력 (0부터 시작했으므로 둘 다 + 1)

# 델타 없이 하나 하나 다 구현하는 방식
bottom, right = map(int, input().split())   # 가장 아래 인덱스, 가장 오른쪽 인덱스 입력값 저장
K = int(input())                            # 입력값 저장
if K > bottom * right:                      # 좌석 수보다 더 높은 좌석 번호를 요구하면
    print(0)                                # 0 출력 
else:
    left, top, newX, newY = 1, 1, 1, 1      # 가장 왼쪽 인덱스, 가장 위쪽 인덱스, x좌표, y좌표 초기화
    K -= 1                                  # 첫 번째 좌석은 이미 배정됐으므로 K - 1
    while K:                                # K가 0이 될 때까지 반복
        while K and newY < right:           # K가 0이 아니고, y좌표가 가장 오른쪽 인덱스보다 작을 때 반복
            K -= 1                          # K - 1
            newY += 1                       # y좌표 + 1   
        top += 1                            # 오른쪽으로 다 갔으면 맨 위 행이 다 채워졌으므로 가장 위쪽 인덱스 + 1   
        while K and newX < bottom:          # K가 0이 아니고, x좌표가 가장 아래쪽 인덱스보다 작을 때 반복
            K -= 1
            newX += 1
        right -= 1                          # 아래쪽으로 다 갔으면 맨 오른쪽 열이 다 채워졌으므로 가장 오른쪽 인덱스 - 1
        while K and left < newY:            # K가 0이 아니고, y좌표가 가장 왼쪽 인덱스보다 클 때 반복
            K -= 1
            newY -= 1
        bottom -= 1                         # 왼쪽으로 다 갔으면 맨 아래쪽 행이 다 채워졌으므로 가장 아래쪽 인덱스 - 1
        while K and top < newX:             # K가 0이 아니고, x좌표가 가장 위쪽 인덱스보다 클 때 반복
            K -= 1
            newX -= 1
        left += 1                           # 위쪽으로 다 갔으면 맨 왼쪽 열이 다 채워졌으므로 가장 왼쪽 인덱스 + 1
    print(newX, newY)                       # x좌표와 y좌표 출력

'''
7 * 6

1   2   3   4   5   6
22  23  36  35  34  7
21  24  37  38  33  8
20  25  42  39  32  9
19  26  41  40  31  10
18  27  28  20  30  11
17  16  15  14  13  12
'''